Q: console.log(+2);
= 2

Q: console.log(+"2");
= 2

Q: console.log(-"2");
= -2

Q: console.log(typeof "2");
= string

Q: console.log(typeof (+"2"));
= number

Q: console.log("2"+3+4);
= 234

Q: console.log(2+3+"4");
= 54

Q: console.log(+"2"+3);
= 5

Q: console.log(2 + +"3");	//+"3" = 3
= 5

Q: console.log(2 + -"3");
= -1

Q: console.log(1 - - "2");	//-"2" = -2
= 3

Q: console.log(2 + +"hi");
= NaN(Not a Number)

Q: How do I convert a float number to a whole number in JavaScript?
=  Positive :
-------------
value = 5.5

Math.floor(value) //  5
Math.ceil(value)  //  6
Math.round(value) //  6
Math.trunc(value) //  5
parseInt(value)   //  5
~~value           //  5	   (Using Bitwise NOT operator)
value | 0         //  5    (Using Bitwise OR operator)
value >> 0        //  5	   
value >>> 0       //  5
value - value % 1 //  5

Negative:
----------
value = -5.5

Math.floor(value) // -6
Math.ceil(value)  // -5
Math.round(value) // -5
Math.trunc(value) // -5
parseInt(value)   // -5
value | 0         // -5
~~value           // -5
value >> 0        // -5
value >>> 0       // 4294967291
value - value % 1 // -5


Q: What is the output of following?
   1. console.log({}+ {});
   2. console.log(+{});
   3. console.log({}+ +{});
   4. console.log({}+ []);
   5. console.log({}+ []+{});
== 1. [object Object][object Object] 	//(for two {} printed [object Object])
   2. NaN
   3. [object Object] NaN
   4. [object Object] 		//(nothing print for [], only [object Object]print for one {})
   5. [object Object][object Object]  // same as above nothing print for [].
   
Q: What is the output of 
	console.log({}==={}); and console.log([]===[]);
== false  false. (both will be treated as two different objects).

Q: What is the output of 
	console.log({}=={}); and console.log([]==[]);
== false  false. 

Q: What is the output of
   var obj1 = {};
   
var obj2 = obj1;

   console.log(obj1 === obj2);
=  true




Regarding the specific output of

console.log(1 +  + "2");
Run it on your browser console. The better question is why does it output what it does -

console.log(1 +  + "2");
              ^
That is the binary + operator, which will concatenate strings or add numbers.

console.log(1 +  + "2");
                 ^
That one is the unary + operator, which converts "2" to a number.
In JavaScript it is possible to use the + operator alone before a single element. This indicates a math operation and tries to convert the element to a number. If the conversion fails, it will evaluate to NaN. This is especially useful when one wants to convert a string to a number quickly, but can also be used on a select set of other types.

The unary + operator, when used on types other than string, will internally attempt to call valueOf() or toString() (in that order) and then attempt to convert the result to a number. Thusly, the unary + operator can successfully convert many of the native JS types with certain restrictions:

Q: 1. console.log(1 +  -"1" + "2");

   2. console.log( "A" + "B" + "2");

   3. console.log( "A" + "B" + 2);
   4. console.log( "A" - "B" + "2");
   
5. console.log( "A" - "B" + 2);
A= 1. 02 
   2. AB2
   3. AB2	
   4. Nan2
   ("A" - "B" + "2" Outputs: "NaN2" Explanation: Since the '-' operator can not be applied to strings, and since neither "A" nor "B" can be converted to numeric values, "A" - "B" yields NaN which is then concatenated with the string "2" to yield “NaN2”.)
   3. Nan
   (As exlained above "A" - "B" yields NaN. But any operator applied to NaN with any other numeric operand will still yield NaN.)

------------

Q:function bob(a)  {

      a = 5;

      console.log(
arguments[0]);

  };
  function bob(a,b)  {

      a = 5;

      console.log(
arguments[0], arguments[1]);

  };

  bob(9,9,9);
A= 5 9

Q: function bob(a,b)  {

      a = 5;

      console.log(
arguments[0], arguments[1]);

  };

   function bob(a)  {

      a = 5;

      console.log(
arguments[0]);

  };

  bob(9,9,9);
A= 5

Q: function bob(a,b)  {

      a = 5;

      console.log(
arguments[0], arguments[1]);

  };

   function bob(a)  {

      a = 5;

      console.log(
arguments[0], arguments[1], arguments[2]);

  };

  bob(9,9,9);
A= 5 9 9

Q: function bob(a,b,c)  {

      a = 5;

      console.log(
arguments[0], arguments[1], arguments[2]);

  };

  bob(9,9,9);
A= 5 9 9

Q: function bob(a,b, c)  {

      a = 5;

      console.log(
arguments[0], arguments[1], arguments[2]);

  };

   function bob(a, b)  {

      a = 5;

      console.log(
arguments[0], arguments[1]);

  };

  bob(9,9,9);
A= 5 9
so whatever is defined latest that will be executed.

Q: Is Javascript support Overloading?
=  There is no overloading in Javascript. You can define the two function with same name with no error. As a result the last one becomes the one that is used.
you can check above example last function is executed in every function.


Q: console.log((10, 1));
A= 1

Q: console.log((10, 100));
A= 100  (later one will be printed, number should be in "( )" );

Q: var a = 4,5,6;
   
console.log(a);

A = Error : Unexpected number.

Q: var a = (4,5,6);
   
console.log(a);

A = 6

Q: [a, b, ...rest] = [1, 2, 3, 4, 5];
   console.log(a); // 1 
   console.log(b); // 2
   console.log(rest); // [3, 4, 5]
A = answers are in comments.


Q: var a=(console.log(1),console.log(2),console.log(3),4);
   console.log(a);
A= 1
   2
   3
   4 // value of a

Q: var a = console.log(1,2 ,3);
   
console.log(a);
=  1 2 3
   undefined  //(value of a is undefined.)

Q: var a=(console.log(1),console.log(2),console.log(3));
   console.log(a);
A= undefined

Q: What is the output of alert("My", "Name", "is", "satty");
== It only shows you "My" in alert, and rest it will not display.

Q: What is the output of alert(1, 2, 3, 4);
== It only shows you 1 in alert, and rest it will not display.

Q: What is the output of console.log("My", "Name", "is", "satty");
== output is "My Name is satty".

Q: What is the output of console.log(1, 2, 3, 4);
== 1 2 3 4

Q: How do you get the variable is object or array?
==
Way 1
------
var arr = []; (or) arr = new Array();
var obj = {}; (or) arr = new Object();

arr.constructor.prototype.hasOwnProperty('push') //true (This is an Array) bcz array has own prototype function push.
obj.constructor.prototype.hasOwnProperty('push') // false (This is an Object)

Way 2
-----
var arr = []; 
var obj = {}; 
console.log(Object.prototype.toString.call(arr));	//prints [object Array]
  means obj is array.
console.log(Object.prototype.toString.call(obj));	//prints [object Object] means obj is object.

Way 3:
-----
All objects inherit a constructor property from their prototype:
var o = {};

console.log(o.constructor === Object); // true

console.log(o.constructor === Array); // false

var a = [];

console.log(a.constructor === Array); // true

console.log(a.constructor === Object); // false

var n = new Number(3);

console.log(n.constructor === Number); // true

Q: Javascript copy array to new array ?
== 
Way1:
---
You can use the .slice method:
var old = ["Apples", "Bananas"];
var newArr = old.slice(0);
newArr.reverse(); 
// now newArr is ["Bananas", "Apples"] and old is ["Apples", "Bananas"]
Array.prototype.slice returns a shallow copy of a portion of an array. Giving it 0 as the first parameter means you are returning a copy of all the elements (starting at index 0 that is)
Way 2:
------
copy one by one in other array using push method.



Q: How do you print consecutive values in setTimeout in for-loop?
I have this script:
for (var i = 1; i <= 5; i++) {
    setTimeout(function() { console.log(i); }, 100);
}
But 5 is alerted five times, instead of 1, 2, 3, 4 and 5.
==  This is because:
1. The timeout function callbacks are all running well after the completion of the loop. In fact, as timers go, even if it was setTimeout(.., 0) on each iteration, all those function callbacks would still run strictly after the completion of the loop, that's why 3 was reflected!
2. all two of those functions, though they are defined separately in each loop iteration, are closed over the same shared global scope, which has, in fact, only one i in it.
Way1:
-----
You can use an immediately-invoked function expression (IIFE) to create a closure around setTimeout:
for (var i = 1; i <= 3; i++) {
    (function(index) {
        setTimeout(function() { alert(index); }, i * 1000);
    })(i);
}
Way2:
------
You can use bind method 
if you want to show as log then solution is:
for (var i = 1; i <= 5; i++) 
{
    
	setTimeout(console.log.bind(console,i), 1000);

}
if you want to show as alert then solution is:
for (var i = 1, j = 1; i <= 3; i++, j++) {
    setTimeout(function() {
        alert(this);
    }.bind(i), j * 100);
}

Q: How do you get a variable is global object?
= The global scope, the space in which global variables live, can also be approached as an object in JavaScript. Each global variable is present as a property of this object. In browsers, the global scope object is stored in the window variable.
var myVar = 10;
console.log("myVar" in window);		// ? true
or
console.log(window.myVar);		// ? 10

Q: How do you create a list in javascript?
=  A list is a nested set of objects, with the first object holding a reference to the second, the second to the third, and so on.
var list = {
  value: 1,
  rest: {
    value: 2,
    rest: {
      value: 3,
      rest: null
    }
  }
};
The resulting objects form a chain, like this:
	 ----------------
	| value:1 | rest |
	 ------------+---
		     |	     -----------------	
		      -----> | value:2 | rest |
			     -------------+---	
					  | 	     ----------------------		
					   -------> |  value:3 | rest:null |
						     ----------------------	

Q: Can we add some extra propetry to string?
= We can read properties like length and toUpperCase from string values. But if you try to add a new property, it doesn’t stick.
var myString = "Fido";
myString.myProperty = "value";
console.log(myString.myProperty);  // ? undefined
Values of type string, number, and Boolean are not objects, and though the language doesn’t complain if you try to set new properties on them, it doesn’t actually store those properties. The values are immutable and cannot be changed.
Most values in JavaScript have properties, the exceptions being "null" and "undefined". Properties are accessed using value.propName or value["propName"]. 

Q: How do you serve Object as a map in javascript?
= Objects can also serve as maps, associating values with names. The "in" operator can be used to find out whether an object contains a property with a given name. The same keyword can also be used in a for loop (for (var name in object)) to loop over an object’s properties.
var map = {};
function storePhi(event, phi) {
  map[event] = phi;
}
storePhi("pizza", 0.069);
storePhi("touched tree", -0.081);
console.log("pizza" in map); 		// ? true
console.log(map["touched tree"]);	// ? -0.081
for (var event in map)
  console.log("The correlation for '" + event + "' is " + map[event]);
// ? The correlation for 'pizza' is 0.069
// ? The correlation for 'touched tree' is -0.081

Q: How do you get all the keys of an object?
=  Using Object.keys(objectvar) method:
var person = { age: 18 };
person.name = 'Joshua';
person['color'] = 'Red';
Object.keys(person); 	//==> ['age', 'name', 'color']

Q: What does an Enumerable and Non-Enumerable properties in Javascript?
=  It isn't very common in the wild but JavaScript (as of ES5) does support non-enumerable properties. That is to say, objects can have properties that don't show up when you do a "for...in" loop over the object or use "Object.keys()" to get an array of property names.
An enumerable property is one that can be included in and visited during for..in loops (or a similar iteration of properties, like Object.keys()).
If a property isn't identified as enumerable, the loop will ignore that it's within the object.
Each of these properties still exists on the object:
A for..in loop then iterates through the object's property names.

var foo = { bar: 1, baz: 2};
for (var prop in foo)
    console.log(prop); 		    // outputs 'bar' and 'baz'
console.log('constructor' in foo); // true
console.log('toString' in foo);    // true
// etc.
But, they're skipped (or "not counted") by the for..in loop because they aren't enumerable.
To create a non-enumerable property we have to use "Object.defineProperty()". A special method for creating properties on an object.

var person = { age: 18 };
Object.defineProperty(person, 'name', { value: 'Joshua', enumerable: false });		// set name as non-enumerable
Object.defineProperty(person, 'city', { value: 'NY', enumerable: true});		// set name as enumerable
person.name; 		// 'Joshua'
Object.keys(person);    // ['age', "city"] but name is not shown in keys

All properties that we create by simply assigning to them are enumerable. The standard properties in Object.prototype are all nonenumerable, which is why they do not show up in such a for/in loop.

It is possible to define our own nonenumerable properties by using the Object.defineProperty function, which allows us to control the type of property we are creating.
Object.defineProperty(Object.prototype, "hiddenNonsense",
                      {enumerable: false, value: "hi"});	// here we are creating the prototpye for object.
prototypes are non-enumerable until we override it from own. so when we use for..in loop or Object.keys() method it will skip prototypes.
but when we check with console.log("hiddenNonsense" in person); it will give us true.

Q: How to create an object without prototype?
= using Object.create(null) method:
var dict1 = Object.create(null);

var dict2 = {};

console.log('toString' in dict1);
	//returns false.
console.log('toString' in dict2);	//returns true.
bcz toString is a prototype in all objects. but dict1 returning null.
There are 2 types of objects: Normal Objects and prototype-less objects:
Normal objects:
Usually, each object you create in JavaScript has at least Object.prototype in its prototype chain. The prototype of Object.prototype is null, so that’s where most prototype chains end.
    > Object.getPrototypeOf({}) === Object.prototype
    true
    > Object.getPrototypeOf(Object.prototype)
    null
Prototype-less objects are better maps:
Prototype-less objects have two advantages as maps:
1. Inherited properties (pitfall #1) are not an issue, any more, simply because there are none. Therefore, you can now freely use the in operator to detect whether a property exists and brackets to read properties.
2. Soon: __proto__ is disabled. In ECMAScript 6, the special property __proto__ will be disabled if Object.prototype is not in the prototype chain of an object. You can expect JavaScript engines to slowly migrate to this behavior, but it is not yet very common.
The only disadvantage is that you’ll lose the services provided by Object.prototype. For example, a dict object can’t be automatically converted to a string, any more:
    > console.log('Result: '+obj)
    TypeError: Cannot convert object to primitive value
But that is not a real disadvantage, because it isn’t safe to directly invoke methods on a dict object, anyway.
if you will run:
console.log(dict1);	// here you will get Object with no properties
console.log(dict2);	// here you will get Object with __proto__ object. inside this __proto__ you will get toString() method.
so console.log(dict2.__proto__.toString());  //will give you the string representation of dict2 project which is not in dict1.


Q: What happens when you extract a method from objects?
= Extracting Methods:
If you extract a method, it loses its connection with the object. On its own, the function is not a method anymore, and this has the value undefined (in strict mode).
As an example, let’s go back to the object jane:
'use strict';
var jane = {
    name: 'Jane',

    describe: function () {
        return 'Person named '+this.name;
    }
};
We want to extract the method describe from jane, put it into a variable func, and call it. However, that doesn’t work:
  var func = jane.describe;
  func()
o/p: TypeError: Cannot read property 'name' of undefined
The solution is to use the method bind() that all functions have. It creates a new function whose this always has the given value:
  var func2 = jane.describe.bind(jane);
  func2()
o/p= 'Person named Jane'

Q: Describe some arrays mehtods?
= Arrays have many methods (see Array Prototype Methods). Here are a few examples:
> var arr = [ 'a', 'b', 'c' ];

> arr.slice(1, 2)  // copy elements
[ 'b' ]
> arr.slice(1)
[ 'b', 'c' ]

> arr.push('x')  // append an element
4
> arr
[ 'a', 'b', 'c', 'x' ]

> arr.pop()  // remove last element
'x'
> arr
[ 'a', 'b', 'c' ]

> arr.shift()  // remove first element
'a'
> arr
[ 'b', 'c' ]

> arr.unshift('x')  // prepend an element
3
> arr
[ 'x', 'b', 'c' ]

> arr.indexOf('b')  // find the index of an element
1
> arr.indexOf('y')
-1

> arr.join('-')  // all elements in a single string
'x-b-c'
> arr.join('')
'xbc'
> arr.join()
'x,b,c'

Q: How you use foreach loop for iterating arrays?
= [ 'a', 'b', 'c' ].forEach(
    function (elem, index) {  // (1)
        console.log(index + '. ' + elem);        // prints 0. a   1. b  2. c
    });

Q: What is coercion in Javascript?
= In JavaScript, the main way of dealing with a value whose type doesn’t fit is to coerce it to the correct type. Coercion means implicit type conversion. Most operands coerce:
> '3' * '4'
= 12
JavaScript’s built-in conversion mechanisms support only the types Boolean, Number, String, and Object. There is no standard way to convert an instance of one constructor to an instance of another constructor.


Q: what is the difference between primitive and nonprimitive values in Javascript?
= Primitive Values:
------------------- 
The following are all of the primitive values (primitives for short):
  --------------------------------------
 | Booleans: true, false		|
 | Numbers: 1736, 1.351 		|
 | Strings: 'abc', "abc" 		|
 |Two “nonvalues”: undefined, null 	|
  --------------------------------------
Primitives have the following characteristics:
A. Compared by value
The “content” is compared:
> 3 === 3
true
> 'abc' === 'abc'
true

B. Always immutable
Properties can’t be changed, added, or removed:
> var str = 'abc';

> str.length = 1; // try to change property `length`
> str.length      // ? no effect
= 3 

> str.foo = 3; // try to create property `foo`
> str.foo      // ? no effect, unknown property
= undefined

C. A fixed set of types
You can’t define your own primitive types

Objects or Non-Primitive Values: 
-------------------------------
All nonprimitive values are objects. The most common kinds of objects are:
 ------------------------------------------------------------------------------------
|  1. Plain objects (constructor Object) can be created by object literals 
|   {
|     firstName: 'Jane',
|     lastName: 'Doe'
|   }
| The preceding object has two properties: the value of property firstName is 'Jane', and the value of property lastName is 'Doe'.
| 2. Arrays (constructor Array) can be created by array literals :
|   [ 'apple', 'banana', 'cherry' ]
| The preceding array has three elements that can be accessed via numeric indices. For example, the index of 'apple' is 0.
| 3. Regular expressions (constructor RegExp) can be created by regular expression literals :
|    /^a+b+$/
 -------------------------------------------------------------------------------------
Objects have the following characteristics:
A. Compared by reference
Identities are compared; every object has its own identity:
> ({} === {})  // two different empty objects
false

> var obj1 = {};
> var obj2 = obj1;
> obj1 === obj2
true

B. Mutable by default
You can normally freely change, add, and remove properties :
> var obj = {};
> obj.foo = 123; // add property `foo`
> obj.foo
123

C. User-extensible
Constructors  can be seen as implementations of custom types (similar to classes in other languages).

Q: How Wrapper Objects Are Different from Primitives?
=  Primitive values such as 'abc' are fundamentally different from wrapper instances such as new String('abc'):
> typeof 'abc'  // a primitive value
= 'string'
> typeof new String('abc')  // an object
= 'object'
> 'abc' instanceof String  // never true for primitives
false
> 'abc' === new String('abc')
= false
Wrapper instances are objects, and there is no way of comparing objects in JavaScript, not even via lenient equals == 
> var a = new String('abc');
> var b = new String('abc');
> a == b
= false
>a===b
= false;

Q: How do you wrap and unwrap primitives?
= Wrapping and Unwrapping Primitives
There is one use case for wrapper objects: you want to add properties to a primitive value. Then you wrap the primitive and add properties to the wrapper object. 
You need to unwrap the value before you can work with it.
1. Wrap a primitive by invoking a wrapper constructor:
new Boolean(true)
new Number(123)
new String('abc')

2. Unwrap a primitive by invoking the method valueOf(). All objects have this method (as discussed in Conversion to Primitive):
> new Boolean(true).valueOf()
true
> new Number(123).valueOf()
123
> new String('abc').valueOf()
'abc'

Converting wrapper objects to primitives properly extracts numbers and strings, but not booleans:
> Boolean(new Boolean(false))  // does not unwrap
true
> Number(new Number(123))  // unwraps
123
> String(new String('abc'))  // unwraps
'abc'

Q: How Primitives Borrow Their Methods from Wrappers?
= Primitives Borrow Their Methods from Wrappers
Primitives don’t have their own methods and borrow them from wrappers:
> 'abc'.charAt === String.prototype.charAt
= true
"Sloppy mode" and "strict mode" handle this borrowing differently. In sloppy mode, primitives are converted to wrappers on the fly:
String.prototype.sloppyMethod = function () {
    console.log(typeof this); // object
    console.log(this instanceof String); // true
};

''.sloppyMethod(); // call the above method
In strict mode, methods from the wrapper prototype are used transparently:
String.prototype.strictMethod = function () {
    'use strict';
    console.log(typeof this); 		 // string  // Note here type of this is string not object.
    console.log(this instanceof String); // false   //Note in strict mode this will not be instance of String.
};

''.strictMethod(); // call the above method

Q: What is the output of 
   var x ;
   console.log(x);
   var x = 4;
   var x = 5;
=  undefined.

Q: function f() {
 
   var x ;

   console.log(x);

   var x = 4;

   var x = 5;

   }
   
f();
=  "undefined" will be printed. [ because inside function, Hoisting only puts the declaration of all variables to top not the values.}

Q: What is an IIFE?
=  This is a common pattern in JavaScript. Ben Alman suggested it be called immediately invoked function expression (IIFE, pronounced “iffy”). In general, an IIFE looks like this:

(function () { // open IIFE
    // inside IIFE
}()); // close IIFE
It is a self-executing anonymous function. The first set of parentheses contain the expressions to be executed, and the second set of parentheses executes those expressions.
It is a useful construct when trying to hide variables from the parent namespace. All the code within the function is contained in the private scope of the function, meaning it can't be accessed at all from outside the function, making it truly private.
Here are some things to note about an IIFE:
1. It is immediately invoked.
2. It must be an expression.
3. The trailing semicolon is required.
With this construct you are creating an anonymous function with its own evaluation environment or closure, and then you immediately evaluate it. The nice thing about this is that you can access the variables declared before the anonymous function, and you can use local variables inside this function without accidentally overwriting an existing variable.
Ex-
for(var i=0; i<5; i++) {
  setTimeout(
     (function(j) {
       return function(){alert(j)};
     })(i), 10);
}
With the immediate evaluation of the outer function you are creating a completely independent variable named j in each iteration, and the current value of i will be copied in to this variable, so you will get the result what was naively expected from the first try.
Also, you can use it for wrapping long code for " =?: " operator like:
 ------------------------
| result = exp_to_test ? (function(){... long_code ...})() : (function(){...})();
 ------------------------

Q: How you convert a number into string in Javascript?
= With method invocations, it is important to distinguish between the floating-point dot and the method invocation dot. Thus, you cannot write "1.toString();" you must use one of the following alternatives:
1.toString()	// gives you the "Uncaught SyntaxError: Invalid or unexpected token" Error
but you can access like any of following: 
1..toString()
1 .toString()  // space before dot
(1).toString()
1.0.toString()

Q: What is Object.defineProperty() method?
=  The Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.
Syntax:
Object.defineProperty(obj, prop, descriptor)
Ex- 
var o = {}; // Creates a new object
// Example of an object property added with defineProperty with a data property descriptor
Object.defineProperty(o, 'a', {
  value: 37,
  writable: true,
  enumerable: true,
  configurable: true
});

Q: What is JSON.stringify and JSON.parse function?
= JavaScript gives us functions, JSON.stringify and JSON.parse, that convert data from and to this format. The first takes a JavaScript value and returns a JSON-encoded string. The second takes such a string and converts it to the value it encodes.
(Note: JSON is case-sensitive here i.e. all in caps)

var string = JSON.stringify({name: "X", born: 1980});
console.log(string);
// ? {"name":"X","born":1980}
console.log(JSON.parse(string).born);
// ? 1980

Q: Can you Share Data Between Objects via a Prototype?
= Yes.

Q: “let” keyword vs “var” keyword in Javascript?
= The difference is scoping. var is scoped to the nearest function block and let is scoped to the nearest enclosing block (both are global if outside any block), which can be smaller than a function block.
Also, variables declared with let are not accessible before they are declared in their enclosing block. As seen in the demo, this will throw an exception.
var:
function varTest() {
  var x = 1;
  if (true) {
    var x = 2;  // same variable!
    console.log(x);  // 2
  }
  console.log(x);  // 2
}

let:
function letTest() {
  let x = 1;
  if (true) {
    let x = 2;  // different variable
    console.log(x);  // 2
  }
  console.log(x);  // 1
}


Q: What does “use strict” do in JavaScript, and what is the reasoning behind it?
= The statement "use strict"; instructs the browser to use the Strict mode, which is a reduced and safer feature set of JavaScript.
This strict context prevents certain actions from being taken and throws more exceptions.
List of features (non-exhaustive)
--------------------------------
1. Disallows global variables. (Catches missing var declarations and typos in variable names)
2. Silent failing assignments will throw error in strict mode (assigning NaN = 5;)
3. Attempts to delete undeletable properties will throw (delete Object.prototype)
4. Requires all property names in an object literal to be unique (var x = {x1: "1", x1: "2"})
5. Function parameter names must be unique (function sum (x, x) {...})
6. Forbids octal syntax (var x = 023; some devs assume wrongly that a preceding zero does nothing to change the number.)
7. Forbids the with keyword
8. eval in strict mode does not introduce new variables
9. Forbids deleting plain names (delete x;)
10.Forbids binding or assignment of the names eval and arguments in any form
11.Strict mode does not alias properties of the arguments object with the formal parameters. (i.e. in function sum (a,b) { return arguments[0] + b;} This works because arguments[0] is bound to a and so on. )
12.arguments.callee is not supported

Q: JavaScript function declaration syntax: var fn = function() {} vs function fn() {} ?
= The two ways are:
function expression:
----------------------
var functionOne = function() {
    // Some code
};
function declaration:
---------------------
function functionTwo() {
    // Some code
}

The difference is that functionOne is a function expression and so only defined when that line is reached, whereas functionTwo is a function declaration and is defined as soon as its surrounding function or script is executed (due to hoisting).

For example, a function expression:
 --------------------------------------
| functionOne();
|
|  var functionOne = function() {
|    console.log("Hello!");
|  };
 --------------------------------------
// TypeError: undefined is not a function

And, a function declaration:
 --------------------------------------
|  functionTwo();
|
|  function functionTwo() {
|    console.log("Hello!");
|  }
 --------------------------------------
// Outputs: "Hello!"

Q: Sort array of objects by string property value in JavaScript?
=  you can pass a callback function in object.sort method to override sort method.
var People = [

    {Name: "Satish", Surname: "Surname"},

    {Name:"Abhay", Surname:"ZZZ"},

    {Name: "Mahesh", Surname: "AAA"
}
];

People.sort( function(val1, val2){
 
  if(val1.Name > val2.Name)

      return 1;
 
  else 
     
      return -1;

});

for(var i in People)

   console.log(People[i]);
Output:  Object {Name: "Abhay", Surname: "ZZZ"}
 	 Object {Name: "Mahesh", Surname: "AAA"}
	 Object {Name: "Satish", Surname: "Surname"}

Q: What is Callback function in Javascript?
= Just like we pass variables/ objects as an arguments in the function, we can pass function as an arguments in the function. We also call it Higher Order Function.
Callbacks functions can be synchronous or asynchronous.
Callback Functions Are Closures. 
Synchronous callbacks are invoked in the original thread, so do not create thread-safety concerns by themselves.
Ex of Synchronous Callback:
array.foreach(item){
 console.log(item.index);
}
console.log("After");
it is synchronous because after will be printed after iteration of full array.
Ex of Asynchronous Callback:
setTimeout(function(){
  console.log("1 sec later");
}, 1000);
console.log("first");
-------------------------------------------------------------------------------

Q: JavaScript Display Possibilities
A= JavaScript can "display" data in different ways:
1. Writing into an alert box, using =				window.alert().
    window.alert(5 + 6);
2. Writing into the HTML output using = 			document.write().
    document.write(5 + 6);
3. Writing into an HTML element, using =			innerHTML.
    document.getElementById("demo").innerHTML = 5 + 6;
4. Writing into the browser console, using =			console.log().

-------------------------------------------------------------------------------
Q: Number Properties in javascript?
=  1.MAX_VALUE		Returns the largest number possible in JavaScript
   ex- var a = Number.MAX_VALUE;
   2.MIN_VALUE		Returns the smallest number possible in JavaScript
   3.NEGATIVE_INFINITY	Represents negative infinity (returned on overflow)
   4.NaN		Represents a "Not-a-Number" value
   5.POSITIVE_INFINITY	Represents infinity (returned on overflow)

Q: JavaScript Number Methods?
=  1. "toString()" returns a number as a string.
     =  var x = 123;
	x.toString();            // returns 123 from variable x
	(123).toString();        // returns 123 from literal 123
	(100 + 23).toString();   // returns 123 from expression 100 + 23
   2. 
     = var x = 9.656;
	x.toExponential(2);     // returns 9.66e+0
	x.toExponential(4);     // returns 9.6560e+0
	x.toExponential(6);     // returns 9.656000e+0
   3. toFixed() returns a string, with the number written with a specified number of decimals:
     = var x = 9.656;
	x.toFixed(0);           // returns 10
	x.toFixed(2);           // returns 9.66
	x.toFixed(4);           // returns 9.6560
	x.toFixed(6);           // returns 9.656000
   4. toPrecision() returns a string, with a number written with a specified length:
     = var x = 9.656;
	x.toPrecision();        // returns 9.656
	x.toPrecision(2);       // returns 9.7
	x.toPrecision(4);       // returns 9.656
	x.toPrecision(6);       // returns 9.65600
   5. valueOf() returns a number as a number.
     = var x = 123;
	x.valueOf();            // returns 123 from variable x
	(123).valueOf();        // returns 123 from literal 123
	(100 + 23).valueOf();   // returns 123 from expression 100 + 23
Global Methods : JavaScript global methods can be used on all JavaScript data types.
1. Number() can be used to convert JavaScript variables to numbers:
  => Ex:  1. x = true;
	Number(x);        // returns 1
	2. x = false;     
	Number(x);        // returns 0
	3. x = new Date();	  //Used on Date(), the Number() method returns the number of milliseconds since 1.1.1970.
	Number(x);        // returns 1404568027739
	4. x = "10"
	Number(x);        // returns 10
	5. x = "10 20"
	Number(x);        // returns NaN
2. parseInt() parses a string and returns a whole number. Spaces are allowed. Only the first number is returned:
 => 	parseInt("10");         // returns 10
	parseInt("10.33");      // returns 10
	parseInt("10 20 30");   // returns 10
	parseInt("10 years");   // returns 10
	parseInt("years 10");   // returns NaN 
3. parseFloat() parses a string and returns a number. Spaces are allowed. Only the first number is returned:
 => 	parseFloat("10");        // returns 10
	parseFloat("10.33");     // returns 10.33
	parseFloat("10 20 30");  // returns 10
	parseFloat("10 years");  // returns 10
	parseFloat("years 10");  // returns NaN
---------------------------------------------------------------
Q: Regular vs Strict Comparison?
=  In regular comparison('=='), data type does not matter whereas in strict comparison('==='), data type does matter. 
   Switch statements in JS allow strict comparison.
   Ex1-  var x = 10;
	switch(x) {
    	case "10": alert("Hello");	// will not display alert.
	}
  Ex2- var x = 10;
var y = "10";
console.log(x==y);  //return true;
  Ex3- var x = 10;
var y = "10";
console.log(x===y); //return false;strict comparison
---------------------------------------------------------------
Q: Misunderstanding Floats?
=  All numbers in JavaScript are stored as 64-bits Floating point numbers (Floats).
All programming languages, including JavaScript, have difficulties with precise floating point values:
Ex- 	var x = 0.1;
	var y = 0.2;
	console.log( x + y );            // the result in z will not be 0.3
= Here the result is  0.30000000000000004
To solve the problem above, it helps to multiply and divide:
	var z = (x * 10 + y * 10) / 10;       
	console.log(z);			// z will be 0.3

Q: What is the output of
	function myFunction(a) {
    		var power = 10  
    		return a * power
	}
=  It will not give error and attach ";" at the end of return line.
----------------------------------------------------------------

Q: What is the DOM and BOM in JavaScript?
= 1. DOM - Document Object Model
     The DOM is the Document Object Model, which deals with the document, the HTML elements themselves, e.g. document and all traversal you would do in it, events, etc.
     The DOM is an API for HTML as well as XML. The DOM maps out the entire page as a document composed of hierarchy of nodes.
	Ex- document.write("<p>Hi,sdfd"</p>);
  2. BOM - Browser Object Model
     The BOM is the Browser Object Model, which deals with browser components aside from the document, like history, location, navigator and screen (as well as some others that vary by browser).

Q: Explain BOM?
= At the very top of this browser hierarchy is the Window object. This represents the entire browser, with its toolbars, menus, status bar, the page itself, and a whole lot more besides. 
 Effectively, the Window IS the browser.Underneath the Window Object there are lots of other objects you can access.Some are:
1. window.document
Allows you to access all your HTML elements. We'll go into more detail about the document object later.
2. window.history
Access information about browsing history. This object is of limited use since you can't get at which pages a user has visited, just how many pages are in the browsing history. You can also access the methods history.back, history.forward and history.go. 
3. window.innerHeight and window.innerWidth
Gets the height and width of the available space on the page
4  window.screen 
Gets information about the browser screen.
You may think that screen is the same as innerHeight and innerWidth but they are not. As an example, create a new HTML page from your template with SCRIPT tags in the HEAD section. 
 ----------------------------------------------------------
| Ex- screen	// type screen in console.
| o/p= screen
Screen {availWidth: 1600, availHeight: 860, width: 1600, height: 900, colorDepth: 24…}
 ----------------------------------------------------------
5. window.navigator
Used to gets information about the browser. The navigator object exposes lots of other objects you can use. For example, there's this one:
window.navigator.cookieEnabled
If you put that between the round brackets of an alert box it will tell you if cookies have been enabled in your browser. This is usually used in an
IF Statement, though. If the answer is yes, then a cookie can be set on a user's computer. If no, then you can ask people to enable cookies.
Other navigator objects are:
a. appName
b. appVersion
c. language
d. platform
e. userAgent
Note: get list of others using console.dir(window.navigator);
6. window.location
	console.log(window.location);
       o/p=  Location {	hash: "", search: "", 
			pathname: "/JS/browser_object_model.html",
			port: "", hostname: "www.homeandlearn.co.uk"…}

Primarily BOM deals with the browser window and frames, but generally browser-specific extension to JS is considered to be a part of BOM. Such things include:
1. The capability to pop-up new browser windows.
2. The capability to move, resize and close browser windows.
3. The navigator object, which provides the detailed information about the web browser.
4. The location object, which provides the detailed information about the page loaded in web browser.
5. The screen object, which provides the detailed information about the user screen's resolution.
6. Support for cookies.
7. Internet Explorer extends the BOM to manipulate the ActiveXObject class, which can be used to instantiate the ActiveXObject through Javascript.
Note*- Because no standards exists for BOM, each browser has its own implementation.
A complete Javascript is made up of 3 distinct parts:
  1. The Core(ECMAScript)	2. The DOM	3. The BOM

Q: How will you Get the browser viewport dimensions with JavaScript?
=  window.innerWidth and .innerHeight
   -------------------------------------
> gets CSS viewport @media (width) and @media (height) which include scrollbars
> initial-scale and zoom variations may cause mobile values to wrongly scale down to what PPK calls the visual viewport and be smaller than the @media values
> zoom may cause values to be 1px off due to native rounding
> undefined in IE8-
document.documentElement.clientWidth and .clientHeight
-----------------------------------------------------
> equals CSS viewport width minus scrollbar width
> matches @media (width) and @media (height) when there is no scrollbar
> same as jQuery(window).width() which jQuery calls the browser viewport

Q: What will window.devicePixelRatio do?
= It gives Physical screen size divided by ideal layout viewport in browsers.

Q: What will window.pageX/YOffset do?
= It gives the visual viewport’s scrolling offset relative to the document.

Q: How will you get Mouse/touch coordinates?
= 1. clientX/Y : In CSS pixels, relative to the visual viewport
  clientX/Y = pageX/Y - window.pageX/YOffset	(visual)  
  clientX/Y = pageX/Y + document.documentElement.getBoundingClientRect().left/top  (layout)
   In browsers that don’t have a modern layout viewport window.pageX/YOffset is equal to -getBounding().left/top, and the coordinates relative to the layout and visual viewport seem to be the same. (In fact, the document element’s offset is calculated relative to the visual viewport.)
  2. pageX/Y : In CSS pixels, relative to the document
  3. screenX/Y : In CSS pixels, relative to the screen
    screenX/Y = (pageX/Y - window.pageX/YOffset) *   (document.documentElement.clientWidth/Height / window.innerWidth/Height) - toolbarOffset;
    toolbarOffset = screen.height - (window.innerHeight * (document.documentElement.clientWidth / window.innerWidth);
  4.element.getBoundingClientRect().left/top returns the position of the element 
Q: Important Data Types of DOM?
=  1. document
   2. element	:element refers to an element or a node of type element returned by a member of the DOM API. for example, that the document.createElement() return element.
   3. nodeList	:A nodeList is an array of elements, like the kind that is returned by the method document.getElementsByTagName(). 
   4. attribute :Attributes are nodes in the DOM just like elements are
   5. namedNodeMapb :A namedNodeMap is like an array, but the items are accessed by name or index, though this latter case is merely a convenience for enumeration, as they are in no particular order in the list.

======================================================================
Q: Define confirm and prompt box in JS?
= 1. Confirm box is just this:
	confirm("OK or Cancel?")
  2. A prompt box is used when you want some input from the user. The code for a Prompt box is this:
	prompt("Favourite Colour?", "Red")	// alert box with textbox, here Red is by default value of textbox.

=======================================================================
Q: How to stop the execution of function specified in the setInterval()  and setTimeout()?
= We have methods clearInterval(myIntervalVar) and clearTimeout(myTimeoutVar) for stopping the execution.
Ex-  The clearInterval() method uses the variable returned from setInterval():
     	myVar = setInterval(function, milliseconds);
   	clearInterval(myVar);  // myVar is returned by setInterval.
=======================================================================
Q: What delete keyword will do?
=  The delete operator removes a property(variable defined in a class) from an object.
Syntax:	1. delete object.property	or
	2. delete object['property']
The delete operator removes a given property from an object. On successful deletion, it will return true, else false will be returned. However, it is important to consider the following scenarios:
1. If the property which you are trying to delete does not exist, delete will not have any effect and will return true
2. If a property with the same name exists on the object's prototype chain, then, after deletion, the object will use the property from the prototype chain (in other words, delete only has an effect on own properties).
3. Any property declared with var cannot be deleted from the global scope or from a function's scope.
 a. As such, delete cannot delete any functions in the global scope (whether this is part from a function definition or a function expression).
 b. Functions which are part of an object (apart from the global scope) can be deleted with delete.
4. Any property declared with 'let' or 'const' cannot be deleted from the scope within which they were defined.
5. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().
Non-configurable properties
--------------------------
When a property is marked as non-configurable, delete won't have any effect, and will return false. In strict mode this will raise a SyntaxError.
 ---------------------------------------------------------------
|	var Employee = {};
|	Object.defineProperty(Employee, 'name', {configurable: false})
|
|	console.log(delete Employee.name);  // returns false
 ---------------------------------------------------------------
var, let and const create non-configurable properties that cannot be deleted with the delete operator.
Ex- var b = [1,2,3];


    delete b[2]; 

    console.log(b);   //[1,2] delete the element at index 2.
Note:-
If the property is an object reference, the delete command deletes the property but not the object. 
The garbage collector will take care of the object if it has no other references to it.
--------------------------------

Q: How do you get a timestamp in JavaScript?
=  1. new Date().getTime()
   2. Date.now();
   3. +new Date;

==============================================================
Q: var a = function(){};
   a.prototype.test = function( p ){
      return p
   }

   var b = function(){};
   b.prototype.test = Object.create(a.prototype.test);

   var c = new a();
   var d = new b();
   console.log(typeof a.test, typeof b.test, typeof c.test, typeof d.test)
   console.log( c.test("Unicorn") );
   console.log( d.test("Unicorn") );
A: o/p:= 
> undefined undefined function object
> "Unicorn"
> TypeError: d.test is not a function  (because d.test is object not a function)

==============================================================
Q: What is arguments.callee in javascript? What are the use cases of it?
= The arguments.callee property contains the currently executing function.
Uses of arguments.callee
--------------------------
1. Using arguments.callee in an anonymous recursive function
the function can refer to itself is by arguments.callee.
 ---------------------------------------------------------------
|  function create() {
|       return function(n) {
|           if (n <= 1)
|          	return 1;
|       	    return n * arguments.callee(n - 1);
|       };
|  }
|
|  var result = create()(5); // returns 120 (5 * 4 * 3 * 2 * 1)  
 ----------------------------------------------------------------
2. A use of arguments.callee with no good alternative
However, in a case like the following, there are not alternatives to arguments.callee, so its deprecation could be a bug:
 ---------------------------------------------------------------
|  function createPerson (sIdentity) {
|       var oPerson = new Function("console.log(arguments.callee.identity);");
|       oPerson.identity = sIdentity;
|       return oPerson;
|   };
|  var john = createPerson("John Smith");
|
|  john(); 
 ----------------------------------------------------------------
// (John Smith) will be printed in console.
==============================================================
Q: How to reference base variable with inheritance or show inheritance in JS?
==  ---------------------------------------------------------
   | var Recorder = function (source) {

   | this.context = source.context;

   | this.recording = null;

   | this.start = function () {

   |	     this.recording = true;
    };

   | this.stop = function () {
        
   |	this.recording = false;
    };

   |   };
   |
   
| var messageRecorder = function() {
    
   |	Recorder.apply(this, arguments);

   |	//used apply method.
   |     this.isRecording = function() {

   |          return this.recording;
    
   |       };
   |  
};

   |
   | var src = {
    context: 'something'
};
   | 
var audioRecorder = new messageRecorder(src);

   | audioRecorder.start();
   | 
console.log("recording? " + audioRecorder.isRecording());

   | audioRecorder.stop();

   | console.log("recording? " + audioRecorder.isRecording());
    -----------------------------------------------------------
==  o/p= | recording? true   |
         | recording? false; |
          -------------------
===============================================================
Q: What is the difference between __prot__ and prototype?
=  nstances have __proto__ whereas classes have prototype.
    ---------------------------------------------------------
   | function Person(name){
   | 	this.name = name
   | }; 
   | Person.prototype.test = "sat";
   |	   
   | var eve = new Person("Eve");
        
   |	
   | console.log(eve.__proto__ == Person.prototype);  //true
   | console.log(eve.__proto__);        // Object {test: "sdfd"}
   
| console.log(eve.prototype);        //undefined
   | console.log(Person.prototype);  	// Object {test: "sdfd"}
    ---------------------------------------------------------
1. Prototype: 
Prototype or Object.prototype is a property of an object literal. It represents the Object prototype object which you can override to add more properties or methods further along the prototype chain.
> When creating a function, a property object called prototype is being created automatically (you didn't create it yourself) and is being attached to the function object (the constructor).
Note: This new prototype object also points to, or has an internal-private link to, the native JavaScript Object.
Ex- in above ex-
 function Person(name){
    
    this.name = name
 }; 
 console.log(Person.Prototype());   // will print empty Object {}.
Note: You can get  prototype by this Object method also: Object.getPrototypeOf(Array.prototype);
2. __proto__ : 
__proto__ is an accessor property (get and set function) that exposes the internal prototype of an object thru which it is accessed.
Ex- var a = [1,2,3];
    console.log(a.__proto__.__proto__); //return Array
    console.log(a.__proto__.__proto__); //return Object {}, which is the parent of Array.
===================================================================

Q: Javscript Scopes?
=  Javascript has two scopes. Global, and functional. If you declare a variable inside a function using the "var" keyword, it will be local to that function, and any inner functions. If you declare a variable outside of a function, it has global scope.
Finally, "if you omit the var keyword when first declaring a variable, javascript assumes you wanted a global variable, no matter where you declare it."
Ex- 
function a() {
   function b() {
      alert('boo')
   }
   var c = 'Bound to local call object.'
   d = 'Bound to global object.'
}
here c is local to function a(). without being preceded by var, 'd' is global. Do this to made d private:
function a() {
   function b() {
      alert('boo')
   }
   var c = 'Bound to local call object.'
   var d = 'Bound to local object.'
}
===================================================================
Q: what will be output of console.log(1 + []);
= It will return string "1".

Q: what will be output of console.log(1 + [0]);
= It will return string "10".

Q: What will be output of console.log(+"");
=  It will give you string "0".

Q: what will be output of console.log( +[]); 
= It will return number 0.  Here [0] will be treated as string "" (well it is an array object but in this case empty string) and +string is treated as number.

Q: Why does ++[[]][+[]]+[+[]] return the string “10”?
=  
1626
down vote
accepted
If we split it up, the mess is equal to:

++[[]][+[]]
+
[+[]]
In JavaScript, it is true that +[] === 0. + converts something into a number, and in this case it will come down to +"" or 0 (see specification details below).

Therefore, we can simplify it (++ has precendence over +):

++[[]][0]
+
[0]
Because [[]][0] means: get the first element from [[]], it is true that:

[[]][0] returns the inner array ([]). Due to references it's wrong to say [[]][0] === [], but let's call the inner array A to avoid the wrong notation.
++[[]][0] == A + 1, since ++ means 'increment by one'.
++[[]][0] === +(A + 1); in other words, it will always be a number (+1 does not necessarily return a number, whereas ++ always does - thanks to Tim Down for pointing this out).
Again, we can simplify the mess into something more legible. Let's substitute [] back for A:

+([] + 1)
+
[0]
In JavaScript, this is true as well: [] + 1 === "1", because [] == "" (joining an empty array), so:

+([] + 1) === +("" + 1), and
+("" + 1) === +("1"), and
+("1") === 1
Let's simplify it even more:

1
+
[0]
Also, this is true in JavaScript: [0] == "0", because it's joining an array with one element. Joining will concatenate the elements separated by ,. With one element, you can deduce that this logic will result in the first element itself.

So, in the end we obtain (number + string = string):

1
+
"0"

=== "10" // Yay!
Specification details for +[]:

This is quite a maze, but to do +[], first it is being converted to a string because that's what + says:

11.4.6 Unary + Operator
------------------------
The unary + operator converts its operand to Number type.

The production UnaryExpression : + UnaryExpression is evaluated as follows:

Let expr be the result of evaluating UnaryExpression.
Return ToNumber(GetValue(expr)).
ToNumber() says:

Object

Apply the following steps:

Let primValue be ToPrimitive(input argument, hint String).
Return ToString(primValue).
ToPrimitive() says:

Object

Return a default value for the Object. The default value of an object is retrieved by calling the [[DefaultValue]] internal method of the object, passing the optional hint PreferredType. The behaviour of the [[DefaultValue]] internal method is defined by this specification for all native ECMAScript objects in 8.12.8.
[[DefaultValue]] says:

8.12.8 [[DefaultValue]] (hint)
-------------------------------
When the [[DefaultValue]] internal method of O is called with hint String, the following steps are taken:

Let toString be the result of calling the [[Get]] internal method of object O with argument "toString".
If IsCallable(toString) is true then,
a. Let str be the result of calling the [[Call]] internal method of toString, with O as the this value and an empty argument list.

b. If str is a primitive value, return str.
The .toString of an array says:

15.4.4.2 Array.prototype.toString ( )

When the toString method is called, the following steps are taken:

Let array be the result of calling ToObject on the this value.
Let func be the result of calling the [[Get]] internal method of array with argument "join".
If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).
Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.
So +[] comes down to +"", because [].join() === "".

Again, the + is defined as:

11.4.6 Unary + Operator
-----------------------
The unary + operator converts its operand to Number type.

The production UnaryExpression : + UnaryExpression is evaluated as follows:

Let expr be the result of evaluating UnaryExpression.
Return ToNumber(GetValue(expr)).
ToNumber is defined for "" as:

The MV of StringNumericLiteral ::: [empty] is 0.
So +"" === 0, and thus +[] === 0.

So, we can simplify [[]][0] to just [] and we have ++[], right? In fact, this is not the case because evaluating ++[] throws an error, which may initially seem confusing. However, a little thought about the nature of ++ makes this clear: it’s used to increment a variable (e.g. ++i) or an object property (e.g. ++obj.count). Not only does it evaluate to a value, it also stores that value somewhere. In the case of ++[], it has nowhere to put the new value (whatever it may be) because there is no reference to an object property or variable to update. In spec terms, this is covered by the internal PutValue operation, which is called by the prefix increment operator.

So then, what does ++[[]][0] do? Well, by similar logic as +[], the inner array is converted to 0 and this value is incremented by 1 to give us a final value of 1. The value of property 0 in the outer array is updated to 1 and the whole expression evaluates to 1.
-----------------------

Q: Why does +!![]+''+(+[]) return the string “10”?
= This one evaluates to the same but a bit smaller
+!![]+''+(+[])
[] - is an array is converted that is converted to 0 when you add or subtract from it, so hence +[] = 0
![] - evaluates to false, so hence !![] evaluates to true
+!![] - converts the true to a numeric value that evaluates to true, so in this case 1
+'' - appends an empty string to the expression causing the number to be converted to string
+[] - evaluates to 0
so is evaluates to

+(true) + '' + (0)
1 + '' + 0
"10"

So now you got that, try this one: 
_=$=+[],++_+''+$   // this will also return "10";


Some examples:
==============
1 + {} 		//    "1[object Object]"
1 + [] 		//    "1"
1 + new Date()  //    "1Wed Jun 19 2013 12:13:25 GMT+0400 (Caucasus Standard Time)"
There's a nice exception that two Objects addition results in NaN:

[] + []   //    ""
[1] + [2] //    "12"
{} + {}   //    NaN
{a:1} + {b:2}     //    NaN
[1, {}] + [2, {}] //    "1,[object Object]2,[object Object]"
===================================================================
Q: Javascript maximum size for types?

In short, unless the browser specified otherwise, variable sizes are not subject to a restriction. As for Ajax: There's no limit, unless defined server-side.

Q: Output of following:
= Object.prototype.toString.call('abc') // [object String]
  Object.prototype.toString.call(/abc/) // [object RegExp]
  Object.prototype.toString.call([1,2,3]) // [object Array]
  Object.prototype.toString.call([1,2,3]).slice(8, -1);  // Array
 
Q: Some caveats in Javascript?
= All of these are subject to one potential problem, and that is the question of how the object in question was constructed. Here are various ways of building objects and the values that the different methods of type checking will return:
 ----------------------------------------------------------
|    // using a named function:
|    function Foo() { this.a = 1; }
    var obj = new Foo();
    (obj instanceof Object);          // true
    (obj instanceof Foo);             // true
    (obj.constructor == Foo);         // true
    (obj.constructor.name == "Foo");  // true

    // let's add some prototypical inheritance
    function Bar() { this.b = 2; }
    Foo.prototype = new Bar();
    obj = new Foo();
    (obj instanceof Object);          // true
    (obj instanceof Foo);             // true
    (obj.constructor == Foo);         // false
    (obj.constructor.name == "Foo");  // false


    // using an anonymous function:
    obj = new (function() { this.a = 1; })();
    (obj instanceof Object);              // true
    (obj.constructor == obj.constructor); // true
    (obj.constructor.name == "");         // true


    // using an anonymous function assigned to a variable
    var Foo = function() { this.a = 1; };
    obj = new Foo();
    (obj instanceof Object);      // true
    (obj instanceof Foo);         // true
    (obj.constructor == Foo);     // true
    (obj.constructor.name == ""); // true


    // using object literal syntax
    obj = { foo : 1 };
    (obj instanceof Object);            // true
    (obj.constructor == Object);        // true
    (obj.constructor.name == "Object"); // true


Q: How to get a list of an object's prototype chain constructor names?
= Way1: With pattern 
 ---------------------------------------------------
|function getConstructorChain(obj, type) {
|    var cs = [], pt = obj;
|    do {
|       if (pt = Object.getPrototypeOf(pt)) cs.push(pt.constructor || null);
|    } while (pt != null);
|    return type == 'names' ? cs.map(function(c) {
|        return c ? c.toString().split(/\s|\(/)[1] : null;
|    }) : cs;
|}
|var d = document.querySelector('div');
|console.log(getConstructorChain(d));
|console.log(getConstructorChain(d, 'names'));
|o/p= Array[6]		(first console o/p)
|        0:function HTMLDivElement()...
| 	1:function HTMLElement()...
|	2:function Element()...
|	3:function Node()...
|	4:function EventTarget()...
|	5:function Object()...
|      Array[6]		(second console o/p)
|        0:"HTMLDivElement"
| 	1:"HTMLElement"
|	2:"Element"
|	3:"Node"
|	4:"EventTarget"
|	5:"Object"
 ---------------------------------------------------
Way2: In each class call SuperClassName.call() method:
 ---------------------------------------------------
|  function Base() {
|    var curConstructor = arguments.callee;
|  	this.constructorList = [curConstructor.name];
|      
|  	while(curConstructor.caller && curConstructor.caller.name !== ''){
|  	  curConstructor = curConstructor.caller;
|  		this.constructorList.push(curConstructor.name);
|  	}
|  	document.write('<p>Base Constructor List: ' + this.constructorList + '</p>');
|  }
|
|  function SubA() {
|    Base.call(this);
|  }
|
|  SubA.prototype = Object.create(Base.prototype);
|
|  function SubA1() {
|    SubA.call(this);
|  }
|
|  SubA1.prototype = Object.create(SubA.prototype);
|
|    var o = new SubA1();
|
|    function oops() {
|      var u = new SubA1();
|    }
|    oops();
|
| o/p: on Html pages you can see:
|   Base Constructor List: Base,SubA,SubA1 
|   Base Constructor List: Base,SubA,SubA1,oops
 --------------------------------------------------- 

Q: What is event delegation in Javascript? What is Event Bubbling and Event Capturing and difference between them?
=

Event bubbling and capturing are two ways of event propagation in the HTML DOM API, when an event occurs in an element inside another element, and both elements have registered a handle for that event. The event propagation mode determines in which order the elements receive the event.
1. With bubbling, the event is first captured and handled by the innermost element and then propagated to outer elements.
2. With capturing, the event is first captured by the outermost element and propagated to the inner elements.
Capturing is also called "trickling", which helps remember the propagation order:
trickle down, bubble up


Q: What is the difference between window.location.href vs window.location.replace ?
= It is better than using window.location.href =, because replace() does not keep the originating page in the session history, meaning the user won't get stuck in a never-ending back-button fiasco. If you want to simulate someone clicking on a link, use location.href. If you want to simulate an HTTP redirect, use location.replace.
For example:
// similar behavior as an HTTP redirect
window.location.replace("http://stackoverflow.com");

// similar behavior as clicking on a link
window.location.href = "http://stackoverflow.com";

Q: How do you find the device is mobile in website with javascript?
= You can use this code
if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
 // some code..
}
> navigator.userAgent will give the details about the user's device.
> To find particular mobile device type, you can go like:
 ----------------------------------------------------------
| var isMobile = {
|    Android: function() {
|        return navigator.userAgent.match(/Android/i);
|    },
|    BlackBerry: function() {
|        return navigator.userAgent.match(/BlackBerry/i);
|    },
|    iOS: function() {
|        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
|    },
|    Opera: function() {
|        return navigator.userAgent.match(/Opera Mini/i);
|    },
|    Windows: function() {
|        return navigator.userAgent.match(/IEMobile/i);
|    },
|    any: function() {
|        return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
|    }
| };
| // To check to see if the user is on any of the supported mobile devices: 
| if( isMobile.any() ) alert('Mobile');
| // To check to see if the user is on a specific mobile device:
| if( isMobile.iOS() ) alert('iOS');
 ----------------------------------------------------------

Q: What is the output of this:
   const myObj1 = {name :'myobj',
                    
		   age :25};

   var sa = JSON.stringify(myObj.toString());
   
console.log(sa);
= "[object Object]" bcz myobj.toString will convert into "object object" before Json format.
So never use toString to stringify Json.stringify(myobj) will give you full json object.


Q: How you will downloading Data with XHR?
= 

Q: What is the difference between MVC and Flux design patterns in Javascript?
=  Flux is used in ReactJs.
MVC Problems
--------------
MVC is a legendary pattern that has been used for various projects since 1976 (it was introduced in Smalltalk-76). It has stood the test of time and most of the biggest projects still use it today. Why even try to replace it?
MVC did not scale well for Facebook’s huge codebase. The main problem for them was the bidirectional communication, where one change can loop back and have cascading effects across the codebase (making things very complicated to debug and understand).
How does Flux solve this? By forcing an unidirectional flow of data between a system’s components.
In general the flow inside the MVC pattern is not well defined. A lot of the bigger implementations do it very differently (e.g. Cocoa MVC vs. Ruby on Rails MVC).
Flux on the other hand is all about controlling the flow inside the app?—?and making it as simple to understand as possible.
The core of the Flux pattern
Flux has four roles: actions, stores, the dispatcher and views. Their responsibilities can be defined as following:
Actions are simple objects with a type property and some data. For example, an action could be {“type”: “IncreaseCount”, “local_data”: {“delta”: 1}}
Stores contain the application’s state and logic. The best abstraction is to think of stores as managing a particular domain of the application. They aren’t the same as models in MVC since models usually try to model single objects, while stores in Flux can store anything
The Dispatcher acts as a central hub. The dispatcher processes actions (for example, user interactions) and invokes callbacks that the stores have registered with it. The dispatcher isn’t the same as controllers in the MVC pattern?—?usually the dispatcher does not have much logic inside it and you can reuse the same dispatcher across projects
Views are controller-views, also very common in most GUI MVC patterns. They listen for changes from the stores and re-render themselves appropriately. Views can also add new actions to the dispatcher, for example, on user interactions. The views are usually coded in React, but it’s not necessary to use React with Flux
The general flow of a Flux application can be defined as following: 
      ----------------------------------------- 
     |	Action -> Dispatcher -> Store -> View  |
      ----------------------------------------- 
The most important thing to note is that every change goes via an action through the dispatcher, illustrated like this:
 --------------------------------------------- 
|	     ------------------ Action        |
|	    |			   ~          |		
|	    ~			   |          |	
|	Dispatcher---->Store---->View         |
|	    ~		 | 	              |
|	    | 		 ~		      |
|	     ---------Action		      |
 --------------------------------------------- 
Note: ~ is > in that corresponding direction.
So how is Flux different from MVC?
The Flow of the app is essential to Flux and there are very strict rules that are enforced by the Dispatcher. In MVC the flow isn’t enforced and most MVC patterns implement it differently
Unidirectional flow: Every change goes through the dispatcher. A store can’t change other stores directly. Same applies for views and other actions. Changes must go through the dispatcher via actions. In MVC it’s very common to have bidirectional flow
Stores don’t need to model anything and can store any application related state. In MVC models try to model something, usually single objects.




